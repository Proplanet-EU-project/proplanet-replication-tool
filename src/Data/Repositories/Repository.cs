using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using ProplanetReplicationTool.Data.Models;

namespace ProplanetReplicationTool.Data.Repositories
{
    /// <inheritdoc cref="IRepository{T}"/>
    public class Repository<T> : IRepository<T> where T : Entity
    {
        private readonly IDbContextFactory<ApplicationDbContext> _dbContextFactory;

        /// <summary>
        /// Constructor for the generic repository pattern
        /// </summary>
        /// <param name="dbContextFactory"></param>
        public Repository(IDbContextFactory<ApplicationDbContext> dbContextFactory)
        {
            _dbContextFactory = dbContextFactory;
        }

        ///<inheritdoc cref="IRepository{T}.GetAllAsync(Expression{Func{T, bool}}, Func{IQueryable{T}, IOrderedQueryable{T}}, Func{IQueryable{T}, IIncludableQueryable{T, object}}, bool, ApplicationDbContext)"/>
        public async Task<List<T>> GetAllAsync(Expression<Func<T, bool>>? predicate = null,
                                            Func<IQueryable<T>, IOrderedQueryable<T>>? orderBy = null,
                                            Func<IQueryable<T>, IIncludableQueryable<T, object?>>? include = null,
                                            bool asNoTracking = true, ApplicationDbContext? dbContext = null)
        {
            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();
            var entities = context.Set<T>();

            IQueryable<T> query = entities;

            if (asNoTracking) query = query.AsNoTracking();

            if (include != null) query = include(query);

            if (predicate != null) query = query.Where(predicate);

            if (orderBy != null) query = orderBy(query);

            var result = await query.ToListAsync();

            if (dbContext == null) await context.DisposeAsync();

            return result;
        }

        /// <inheritdoc cref="IRepository{T}.GetSingleOrDefaultAsync(Expression{Func{T, bool}}, Func{IQueryable{T}, IIncludableQueryable{T, object}}, bool, ApplicationDbContext)"/>
        public async Task<T?> GetSingleOrDefaultAsync(Expression<Func<T, bool>>? predicate = null,
                                                    Func<IQueryable<T>, IIncludableQueryable<T, object?>>? include = null,
                                                    bool asNoTracking = true, ApplicationDbContext? dbContext = null)
        {
            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();
            var entities = context.Set<T>();

            IQueryable<T> query = entities;

            if (asNoTracking) query = query.AsNoTracking();

            if (include != null) query = include(query);

            if (predicate != null) query = query.Where(predicate);

            var result = await query.SingleOrDefaultAsync();

            if (dbContext == null) await context.DisposeAsync();

            return result;
        }

        /// <inheritdoc cref="IRepository{T}.GetByIdAsync(Guid, Func{IQueryable{T}, IIncludableQueryable{T, object}}, bool, ApplicationDbContext)"/>
        public async Task<T?> GetByIdAsync(Guid id, Func<IQueryable<T>, IIncludableQueryable<T,
                                        object?>>? include = null, bool asNoTracking = true,
                                        ApplicationDbContext? dbContext = null)
        {
            return await GetSingleOrDefaultAsync(predicate: item => item.Id == id, include: include, asNoTracking: asNoTracking, dbContext: dbContext);
        }

        /// <inheritdoc cref="IRepository{T}.AddAsync(T, ApplicationDbContext?)"/>
        /// <remarks>
        /// This method is made with an update due to the fact that in .NET update means AddOrUpdate when the id is autogenerated
		/// So if you are going to add a new entity make sure you don't write the id and if you add a children,
		/// leave the same children ID, NamedEntity Name, TranslatedName and all of the other properties, so it dont update them in the DB
        /// </remarks>
        public async Task<(bool, string?)> AddAsync(T entity, ApplicationDbContext? dbContext = null)
        {
            if (entity == null) throw new ArgumentNullException(nameof(entity));

            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();

            bool rowsChanged = false;
            string? errorMessage = null;

            try
            {
                context.Update(entity);
                rowsChanged = await context.SaveChangesAsync() > 0;
            }
            catch (Exception e) { errorMessage = e.Message; }
            finally { if (dbContext == null) await context.DisposeAsync(); }

            return (rowsChanged, errorMessage);
        }

        /// <inheritdoc cref="IRepository{T}.AddRangeAsync(List{T}, ApplicationDbContext)"/>
        /// <remarks>As in AddAsync this method is done with an UpdateRange.
        /// So if you are going to add a list new employees make sure you don't write the id and if you add a children,
		/// leave the same childrens ID, NamedEntity Name, TranslatedName and all of the other properties, so it dont update them in the DB
        /// </remarks>
        public async Task<(bool, string?)> AddRangeAsync(List<T> entities, ApplicationDbContext? dbContext = null)
        {
            if (entities == null) throw new ArgumentNullException(nameof(entities));

            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();

            var rowsChanged = false;
            string? errorMessage = null;

            try
            {
                context.UpdateRange(entities);
                rowsChanged = await context.SaveChangesAsync() > 0;
            }
            catch (Exception e) { errorMessage = e.Message; }
            finally { if (dbContext == null) await context.DisposeAsync(); }

            return (rowsChanged, errorMessage);
        }

        /// <inheritdoc cref="IRepository{T}.UpdateAsync(T, ApplicationDbContext)"/>
        public async Task<(bool, string?)> UpdateAsync(T entity, ApplicationDbContext? dbContext = null)
        {
            if (entity == null) throw new ArgumentNullException(nameof(entity));

            // Updating entity last updated datetime
            entity.UpdateLastUpdatedAt();

            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();

            var rowsChanged = false;
            string? errorMessage = null;

            try
            {
                context.Update(entity);
                rowsChanged = await context.SaveChangesAsync() > 0;
            }
            catch (Exception e)
            {
                errorMessage = e.Message;
            }
            finally
            {
                if (dbContext == null) context.Dispose();
            }

            return (rowsChanged, errorMessage);
        }

        /// <inheritdoc cref="IRepository{T}.RemoveAsync(T, ApplicationDbContext)"/>
        public async Task<(bool, string?)> RemoveAsync(Guid id, ApplicationDbContext? dbContext = null)
        {
            var entity = await GetByIdAsync(id, dbContext: dbContext);
            if (entity == null) throw new ArgumentNullException(nameof(entity));

            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();

            bool rowsChanged = false;
            string? errorMessage = null;

            try
            {
                context.Remove(entity);
                rowsChanged = await context.SaveChangesAsync() > 0;
            }
            catch (Exception e)
            {
                errorMessage = e.Message;
            }
            finally
            {
                if (dbContext == null) context.Dispose();
            }

            return (rowsChanged, errorMessage);
        }

        /// <inheritdoc cref="IRepository{T}.RemoveRangeAsync(List{T}, ApplicationDbContext)"/>
        public async Task<(bool, string?)> RemoveRangeAsync(List<Guid> ids, ApplicationDbContext? dbContext = null)
        {
            var entities = await GetAllAsync(predicate: item => ids.Contains(item.Id), dbContext: dbContext);
            if (entities == null) throw new ArgumentNullException(nameof(entities));

            var context = dbContext ?? await _dbContextFactory.CreateDbContextAsync();

            bool rowsChanged = false;
            string? errorMessage = null;

            try
            {
                context.RemoveRange(entities);
                rowsChanged = await context.SaveChangesAsync() > 0;
            }
            catch (Exception e)
            {
                errorMessage = e.Message;
            }
            finally
            {
                if (dbContext == null) context.Dispose();
            }

            return (rowsChanged, errorMessage);
        }
    }

    /// <summary>
    /// Interface for the generic repository pattern
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface IRepository<T>
    {
        /// <summary>
        /// Gets all the entities of <see cref="IRepository{T}"/> that match the given expression
        /// </summary>
        /// <param name="predicate">A function to test each element for a condition (optional)</param>
        /// <param name="orderBy">An expression to be applied to order the entities (optional)</param>
        /// <param name="include">An expression to be applied to include child entities (optional)</param>
        /// <param name="asNoTracking">Boolean to use AsNoTracking when getting the entities. Defaults to true</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>The entity with the given id or null if it is not found></returns>
        /// <remarks>This method defaults to no tracking query</remarks>
        /// <example>
        /// Usage:
        /// <code>
        /// // After injecting the repository into _operationLogRepository for data class OperationLog
        /// List<OperationLog> opLogs = await _operationLogRepository.GetAllAsync(
        ///     predicate: op => op.Name == "Unnamed",
        ///     orderBy: op => op.OrderBy(op => op.StartDateTime),
        ///     include: op => op.Include(op => op.MachiningProcess),
        ///     asNoTracking: true);
        /// </code>
        /// </example>
        public Task<List<T>> GetAllAsync(
            Expression<Func<T, bool>>? predicate = null,
            Func<IQueryable<T>, IOrderedQueryable<T>>? orderBy = null,
            Func<IQueryable<T>, IIncludableQueryable<T, object>>? include = null,
            bool asNoTracking = true, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Gets the single entity of <see cref="IRepository{T}"/> that matches the given predicate.
        /// </summary>
        /// <param name="predicate">A function to test each element for a condition (optional)</param>
        /// <param name="include">An expression to be applied to include child entities (optional)</param>
        /// <param name="asNoTracking">Boolean to use AsNoTracking when getting the entities. Defaults to true</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>The entity with the given id or null if it is not found></returns>
        /// <remarks>This method defaults to no tracking query</remarks>
        /// <example>
        /// Usage:
        /// <code>
        /// // After injecting the repository into _operationLogRepository for data class OperationLog
        /// List<OperationLog> opLogs = await _operationLogRepository.GetSingleOrDefaultAsync(
        ///     predicate: op => op.Id == "847ccec3-3bea-43a6-997f-8497d6da3412",
        ///     include: op => op.Include(op => op.MachiningProcess),
        ///     asNoTracking: true);
        /// </code>
        /// </example>
        public Task<T?> GetSingleOrDefaultAsync(Expression<Func<T, bool>> predicate,
            Func<IQueryable<T>, IIncludableQueryable<T, object>>? include = null,
            bool asNoTracking = true, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Gets the single entity of <see cref="IRepository{T}"/> that matches the given id.
        /// </summary>
        /// <param name="id">id of the item</param>
        /// <param name="include">An expression to be applied to include child entities (optional)</param>
        /// <param name="asNoTracking">Boolean to use AsNoTracking when getting the entities. Defaults to true</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>The entity with the given id or null if it is not found></returns>
        /// <remarks>This method defaults to no tracking query</remarks>
        public Task<T?> GetByIdAsync(Guid id, Func<IQueryable<T>, IIncludableQueryable<T,
                                        object?>>? include = null, bool asNoTracking = true,
                                        ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Persist a new entity of <see cref="IRepository{T}"/>
        /// </summary>
        /// <param name="entity">Entity to be added</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>A tuple (bool, string). The bool represents the call success and the string any possible message.</returns>
        public Task<(bool, string?)> AddAsync(T entity, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Persist a new a collection of entities of <see cref="IRepository{T}"/>
        /// </summary>
        /// <param name="entities">List of entities to be added</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>A tuple (bool, string). The bool represents the call success and the string any possible message.</returns>
        public Task<(bool, string?)> AddRangeAsync(List<T> entities, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Updates an existing entity of <see cref="IRepository{T}"/>
        /// </summary>
        /// <param name="entity">Updated entity</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>A tuple (bool, string). The bool represents the call success and the string any possible message.</returns>
        public Task<(bool, string?)> UpdateAsync(T entity, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Removes an existing entity of <see cref="IRepository{T}"/>
        /// </summary>
        /// <param name="id">Entity to be removed</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>A tuple (bool, string). The bool represents the call success and the string any possible message.</returns>
        public Task<(bool, string?)> RemoveAsync(Guid id, ApplicationDbContext? dbContext = null);

        /// <summary>
        /// Removes a collection of entities of <see cref="IRepository{T}"/>
        /// </summary>
        /// <param name="ids">List of entities to be removed</param>
        /// <param name="dbContext">The application database context (optional)</param>
        /// <returns>A tuple (bool, string). The bool represents the call success and the string any possible message.</returns>
        public Task<(bool, string?)> RemoveRangeAsync(List<Guid> ids, ApplicationDbContext? dbContext = null);
    }
}